import os
import json
import logging
import collections

import bhabana.utils as utils

from glob import glob
from bhabana.utils.generic_utils import to_categorical
from bhabana.utils import data_utils as du

logger = logging.getLogger(__name__)

class AmazonReviewsGerman(object):
    def __init__(self, data_balancing=True):

        self.dataset_name = 'Amazon Reviews Dataset'
        self.dataset_description = 'This dataset has been generated by ' \
                                   'scraping German Amazon Reviews'
        self.test_split = "large"
        self.dataset = "amazon_reviews_de"
        self.dataset_path = os.path.join(utils.DATASET_DIR,
                                         self.dataset)
        self.data_balancing = data_balancing
        self.data_path = os.path.join(self.dataset_path, 'reviews.txt')
        self.train_path = os.path.join(self.dataset_path, 'train', 'train.txt')
        self.train_path_list = glob(os.path.join(self.dataset_path, 'train',
                                                 'output_file_*.txt'))
        self.validation_path = os.path.join(self.dataset_path, 'validation',
                                            'validation.txt')
        self.test_path = os.path.join(self.dataset_path, 'test', 'test.txt')
        self.vocab_path = os.path.join(self.dataset_path, 'vocab.txt')
        self.metadata_path = os.path.abspath(os.path.join(self.dataset_path,
                                               'metadata.txt'))
        self.w2v_path = os.path.join(self.dataset_path, 'w2v.npy')

        self.w2i, self.i2w = du.load_vocabulary(self.vocab_path)
        self.w2v = du.load_w2v(self.w2v_path)

        self.vocab_size = len(self.w2i)
        if not self.data_balancing:
            self.train = DataSet(self.train_path, (self.w2i, self.i2w))
        else:
            self.train = DataSetBalanced(self.train_path_list, (self.w2i, self.i2w))
        self.validation = DataSet(self.validation_path, (self.w2i, self.i2w))
        self.test = DataSet(self.test_path, (self.w2i, self.i2w))
        self.__refresh(load_w2v=False)

    def create_vocabulary(self, min_frequency=5, tokenizer='spacy',
                          downcase=False, max_vocab_size=None,
                          name='new', load_w2v=True):
        def line_processor(line):
            json_obj = json.loads(line)
            line = json_obj["review_header"] + " " + json_obj["review_text"]
            return line

        self.vocab_path, self.w2v_path, self.metadata_path = \
            du.new_vocabulary([self.data_path], self.dataset_path,
                                    min_frequency, tokenizer=tokenizer,
                                    downcase=downcase,
                                    max_vocab_size=max_vocab_size, name=name,
                                    line_processor=line_processor, lang='de')
        self.__refresh(load_w2v)

    def __refresh(self, load_w2v):
        self.w2i, self.i2w = du.load_vocabulary(self.vocab_path)
        self.vocab_size = len(self.w2i)
        if load_w2v:
            self.w2v = du.preload_w2v(self.w2i, lang='de')
            du.save_w2v(self.w2v_path, self.w2v)
        self.train.set_vocab((self.w2i, self.i2w))
        self.validation.set_vocab((self.w2i, self.i2w))
        self.test.set_vocab((self.w2i, self.i2w))


class DataSetBalanced(object):
    def __init__(self, path_list, vocab):

        self.path_list = path_list
        self._epochs_completed = 0
        self.vocab_w2i = vocab[0]
        self.vocab_i2w = vocab[1]
        self.datafile = None

        self.Batch = collections.namedtuple('Batch', ['text', 'sentences',
                                                     'ratings', 'titles', 'lengths'])

    def open(self):
        self.datafile = open(self.path_list[0], 'r')

    def close(self):
        self.datafile.close()

    def next_batch(self, batch_size=64, seq_begin=False, seq_end=False,
                   rescale=None, pad=0, raw=False, mark_entities=False,
                   tokenizer='spacy', sentence_pad=0, one_hot=False):
        if not self.datafile:
            raise Exception('The dataset needs to be open before being used. '
                            'Please call dataset.open() before calling '
                            'dataset.next_batch()')
        text, sentences, ratings, titles, lengths = [], [], [], [], []

        while len(text) < batch_size:
            row = self.datafile.readline()
            if row == '':
                self._epochs_completed += 1
                self.close()
                self.datafile = open(self.path_list[self.epochs_completed % len(self.path_list)])
                continue
            try:
                json_obj = json.loads(row.strip())
            except:
                logger.warning('Skipped row!')
                continue
            text.append(du.tokenize(json_obj["review_text"], tokenizer))
            lengths.append(len(text[-1]))
            sentences.append(du.sentence_tokenizer(json_obj["review_text"]))
            ratings.append(int(json_obj["review_rating"]))
            titles.append(du.tokenize(json_obj["review_header"]))


        if rescale is not None and one_hot == False:
            ratings = du.rescale(ratings, rescale, [1.0, 5.0])
        elif rescale is None and one_hot == True:
            ratings = [x - 1 for x in ratings]
            ratings = to_categorical(ratings, nb_classes=5)
        elif rescale is None and one_hot == False:
            pass
        else:
            raise ValueError('rescale and one_hot cannot be set together')
        if mark_entities:
            text = du.mark_entities(text, lang='de')
            titles = du.mark_entities(titles, lang='de')
            sentences = [du.mark_entities(sentence, lang='de')
                         for sentence in sentences]

        if not raw:
            text = du.seq2id(text[:batch_size], self.vocab_w2i, seq_begin,
                                  seq_end)
            titles = du.seq2id(titles[:batch_size], self.vocab_w2i,
                                     seq_begin, seq_end)
            sentences = [du.seq2id(sentence, self.vocab_w2i,
                     seq_begin, seq_end) for sentence in sentences[:batch_size]]
        else:
            text = du.append_seq_markers(text[:batch_size],
                                               seq_begin, seq_end)
            titles = du.append_seq_markers(titles[:batch_size],
                                                 seq_begin, seq_end)
            sentences = [du.append_seq_markers(sentence, seq_begin,
                         seq_end) for sentence in sentences[:batch_size]]

        if pad != 0:
            text = du.padseq(text[:batch_size], pad, raw)
            titles = du.padseq(titles[:batch_size], pad, raw)
            sentences = [du.padseq(sentence, pad, raw) for sentence in
                         sentences[:batch_size]]
        if sentence_pad != 0:
            sentences = [du.pad_sentences(sentence, sentence_pad, raw) for
                         sentence in sentences[:batch_size]]

        batch = self.Batch(text=text, sentences=sentences,
                           ratings=ratings, titles=titles, lengths=lengths)
        return batch

    def set_vocab(self, vocab):
        self.vocab_w2i = vocab[0]
        self.vocab_i2w = vocab[1]

    @property
    def epochs_completed(self):
        return self._epochs_completed



class DataSet(object):
    def __init__(self, path, vocab):

        self.path = path
        self._epochs_completed = 0
        self.vocab_w2i = vocab[0]
        self.vocab_i2w = vocab[1]
        self.datafile = None

        self.Batch = collections.namedtuple('Batch', ['text', 'sentences',
                                                     'ratings', 'titles', 'lengths'])

    def open(self):
        self.datafile = open(self.path, 'r')

    def close(self):
        self.datafile.close()

    def next_batch(self, batch_size=64, seq_begin=False, seq_end=False,
                   rescale=None, pad=0, raw=False, mark_entities=False,
                   tokenizer='spacy', sentence_pad=0, one_hot=False):
        if not self.datafile:
            raise Exception('The dataset needs to be open before being used. '
                            'Please call dataset.open() before calling '
                            'dataset.next_batch()')
        text, sentences, ratings, titles, lengths = [], [], [], [], []

        while len(text) < batch_size:
            row = self.datafile.readline()
            if row == '':
                self._epochs_completed += 1
                self.datafile.seek(0)
                continue
            json_obj = json.loads(row.strip())
            text.append(du.tokenize(json_obj["review_text"], tokenizer))
            lengths.append(len(text[-1]))
            sentences.append(du.sentence_tokenizer(json_obj["review_text"]))
            ratings.append(int(json_obj["review_rating"]))
            titles.append(du.tokenize(json_obj["review_header"]))


        if rescale is not None and one_hot == False:
            ratings = du.rescale(ratings, rescale, [1.0, 5.0])
        elif rescale is None and one_hot == True:
            ratings = [x - 1 for x in ratings]
            ratings = to_categorical(ratings, nb_classes=5)
        elif rescale is None and one_hot == False:
            pass
        else:
            raise ValueError('rescale and one_hot cannot be set together')
        if mark_entities:
            text = du.mark_entities(text, lang='de')
            titles = du.mark_entities(titles, lang='de')
            sentences = [du.mark_entities(sentence, lang='de')
                         for sentence in sentences]

        if not raw:
            text = du.seq2id(text[:batch_size], self.vocab_w2i, seq_begin,
                                   seq_end)
            titles = du.seq2id(titles[:batch_size], self.vocab_w2i,
                                     seq_begin, seq_end)
            sentences = [du.seq2id(sentence, self.vocab_w2i,
                                         seq_begin, seq_end) for sentence in sentences[:batch_size]]
        else:
            text = du.append_seq_markers(text[:batch_size],
                                               seq_begin, seq_end)
            titles = du.append_seq_markers(titles[:batch_size],
                                                 seq_begin, seq_end)
            sentences = [du.append_seq_markers(sentence, seq_begin,
                                                     seq_end) for sentence in sentences[:batch_size]]

        if pad != 0:
            text = du.padseq(text[:batch_size], pad, raw)
            titles = du.padseq(titles[:batch_size], pad, raw)
            sentences = [du.padseq(sentence, pad, raw) for sentence in
                         sentences[:batch_size]]
        if sentence_pad != 0:
            sentences = [du.pad_sentences(sentence, sentence_pad, raw) for
                         sentence in sentences[:batch_size]]

        batch = self.Batch(text=text, sentences=sentences,
                           ratings=ratings, titles=titles, lengths=lengths)
        return batch

    def set_vocab(self, vocab):
        self.vocab_w2i = vocab[0]
        self.vocab_i2w = vocab[1]

    @property
    def epochs_completed(self):
        return self._epochs_completed
